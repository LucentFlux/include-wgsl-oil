NEWLINE    = _{ "\r\n" | "\r" | "\n" | "\u{0B}" | "\u{0C}" | "\u{0085}" | "\u{2028}" | "\u{2029}" }
WHITESPACE = _{ " " | NEWLINE | "\t" | "\u{200E}" | "\u{200F}" }

LINE_COMMENT      = _{ "//" ~ (!NEWLINE ~ ANY)* }
MULTILINE_COMMENT = _{ "/*" ~ (MULTILINE_COMMENT | (!"/*" ~ !"*/" ~ ANY))* ~ "*/" }
COMMENT           = _{ LINE_COMMENT | MULTILINE_COMMENT }

BOOLEAN_LITERAL       =  { "true" | "false" }
INT_LITERAL_SUFFIX    = @{ ("i" | "u") ~ !CONTINUE }
DECIMAL_INT_LITERAL   = @{
    ("0" ~ INT_LITERAL_SUFFIX?)
  | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ~ INT_LITERAL_SUFFIX?)
}
HEX_INT_LITERAL       = @{ "0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+ ~ INT_LITERAL_SUFFIX? }
INT_LITERAL           = @{ DECIMAL_INT_LITERAL | HEX_INT_LITERAL }
FLOAT_LITERAL_SUFFIX  = @{ ("f" | "h") ~ !CONTINUE }
DECIMAL_FLOAT_LITERAL = @{
    ("0" ~ FLOAT_LITERAL_SUFFIX)
  | (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ~ FLOAT_LITERAL_SUFFIX)
  | (ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? ~ FLOAT_LITERAL_SUFFIX?)
  | (ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? ~ FLOAT_LITERAL_SUFFIX?)
  | (ASCII_DIGIT+ ~ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ ~ FLOAT_LITERAL_SUFFIX?)
}
HEX_FLOAT_LITERAL     = @{
    ("0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT* ~ "." ~ ASCII_HEX_DIGIT+ ~ (("p" | "P") ~ ("+" | "-")? ~ ASCII_DIGIT+ ~ FLOAT_LITERAL_SUFFIX?)?)
  | ("0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+ ~ "." ~ ASCII_HEX_DIGIT* ~ (("p" | "P") ~ ("+" | "-")? ~ ASCII_DIGIT+ ~ FLOAT_LITERAL_SUFFIX?)?)
  | ("0" ~ ("x" | "X") ~ ASCII_HEX_DIGIT+ ~ ("p" | "P") ~ ("+" | "-")? ~ ASCII_DIGIT+ ~ FLOAT_LITERAL_SUFFIX?)
}
FLOAT_LITERAL         = @{ DECIMAL_FLOAT_LITERAL | HEX_FLOAT_LITERAL }

LITERAL = { FLOAT_LITERAL | INT_LITERAL | BOOLEAN_LITERAL }

START    = @{ XID_START | "\u{005F}" }
CONTINUE = @{ START | XID_CONTINUE }
IDENT    = @{
    ("_" ~ START ~ CONTINUE*)
  | (START ~ CONTINUE*)
}

TEMPLATE_ARG_EXPRESSION = { TEMPLATE_EXPRESSION }
TEMPLATE_LIST           = {
    // MODIFICATION FROM WGSL - template lists may be empty
    "<" ~ (TEMPLATE_ARG_EXPRESSION ~ ("," ~ TEMPLATE_ARG_EXPRESSION)* ~ ","?)? ~ ">"
}

ATTRIBUTE_INNER = {
    IDENT ~ ("(" ~ EXPRESSION ~ ("," ~ EXPRESSION)* ~ ","? ~ ")")?
}
ATTRIBUTE       = { "@" ~ ATTRIBUTE_INNER }
ATTRIBUTE_SET   = { ATTRIBUTE* }

DIAGNOSTIC_KEYWORD      = @{ "diagnostic" ~ !CONTINUE }
DIAGNOSTIC_DIRECTIVE    =  {
    DIAGNOSTIC_KEYWORD ~ IDENT ~ ";"
}
ENABLE_EXTENSION_NAME   =  { IDENT }
ENABLE_EXTENSION_LIST   =  {
    ENABLE_EXTENSION_NAME ~ ("," ~ ENABLE_EXTENSION_NAME)* ~ ","?
}
ENABLE_KEYWORD          = @{ "enable" ~ !CONTINUE }
ENABLE_DIRECTIVE        =  {
    ENABLE_KEYWORD ~ ENABLE_EXTENSION_LIST ~ ";"
}
SOFTWARE_EXTENSION_NAME =  { IDENT }
SOFTWARE_EXTENSION_LIST =  {
    SOFTWARE_EXTENSION_NAME ~ ("," ~ SOFTWARE_EXTENSION_NAME)* ~ ","?
}
REQUIRES_KEYWORD        = @{ "requires" ~ !CONTINUE }
REQUIRES_DIRECTIVE      =  {
    REQUIRES_KEYWORD ~ SOFTWARE_EXTENSION_LIST ~ ";"
}
GLOBAL_DIRECTIVE        =  {
    DIAGNOSTIC_DIRECTIVE
  | ENABLE_DIRECTIVE
  | REQUIRES_DIRECTIVE
}

TEMPLATE_ELABORATED_IDENT = { IDENT ~ TEMPLATE_LIST? }
TYPE_SPECIFIER            = { TEMPLATE_ELABORATED_IDENT }

STRUCT_MEMBER    =  {
    ATTRIBUTE_SET ~ IDENT ~ ":" ~ TYPE_SPECIFIER
}
STRUCT_BODY_DECL =  {
    "{" ~ STRUCT_MEMBER ~ ("," ~ STRUCT_MEMBER)* ~ ","? ~ "}"
}
STRUCT_KEYWORD   = @{ "struct" ~ !CONTINUE }
STRUCT_DECL      =  {
    STRUCT_KEYWORD ~ IDENT ~ STRUCT_BODY_DECL
}

ALIAS_KEYWORD   = @{ "alias" ~ !CONTINUE }
TYPE_ALIAS_DECL =  { ALIAS_KEYWORD ~ IDENT ~ "=" ~ TYPE_SPECIFIER }

OPTIONALLY_TYPED_IDENT      =  {
    IDENT ~ (":" ~ TYPE_SPECIFIER)?
}
VAR_KEYWORD                 = @{ "var" ~ !CONTINUE }
VARIABLE_DECL               =  {
    VAR_KEYWORD ~ TEMPLATE_LIST? ~ OPTIONALLY_TYPED_IDENT
}
LET_KEYWORD                 = @{ "let" ~ !CONTINUE }
CONST_KEYWORD               = @{ "const" ~ !CONTINUE }
VARIABLE_OR_VALUE_STATEMENT =  {
    VARIABLE_DECL
  | (VARIABLE_DECL ~ "=" ~ EXPRESSION)
  | (LET_KEYWORD ~ OPTIONALLY_TYPED_IDENT ~ "=" ~ EXPRESSION)
  | (CONST_KEYWORD ~ OPTIONALLY_TYPED_IDENT ~ "=" ~ EXPRESSION)
}
GLOBAL_VARIABLE_DECL        =  {
    ATTRIBUTE_SET ~ VARIABLE_DECL ~ ("=" ~ EXPRESSION)?
}
OVERRIDE_KEYWORD            = @{ "override" ~ !CONTINUE }
GLOBAL_VALUE_DECL           =  {
    (CONST_KEYWORD ~ OPTIONALLY_TYPED_IDENT ~ "=" ~ EXPRESSION)
  | (ATTRIBUTE_SET ~ OVERRIDE_KEYWORD ~ OPTIONALLY_TYPED_IDENT ~ ("=" ~ EXPRESSION)?)
}

CALL_PHRASE         = {
    TEMPLATE_ELABORATED_IDENT ~ "(" ~ (EXPRESSION ~ ("," ~ EXPRESSION)* ~ ","?)? ~ ")"
}
CALL_EXPRESSION     = {
    CALL_PHRASE
}
FUNC_CALL_STATEMENT = { CALL_PHRASE }

PAREN_EXPRESSION = {
    "(" ~ EXPRESSION ~ ")"
}

PRIMARY_EXPRESSION = {
    CALL_EXPRESSION
  | LITERAL
  | PAREN_EXPRESSION
  | TEMPLATE_ELABORATED_IDENT
}

RGBA_SWIZZLE_NAME = { "r" | "g" | "b" | "a" }
XYZW_SWIZZLE_NAME = { "x" | "y" | "z" | "w" }
SWIZZLE_NAME      = {
    (RGBA_SWIZZLE_NAME ~ (RGBA_SWIZZLE_NAME ~ (RGBA_SWIZZLE_NAME ~ RGBA_SWIZZLE_NAME?)?)?)
  | (XYZW_SWIZZLE_NAME ~ (XYZW_SWIZZLE_NAME ~ (XYZW_SWIZZLE_NAME ~ XYZW_SWIZZLE_NAME?)?)?)
}

INDEX_EXPRESSION               = { "[" ~ EXPRESSION ~ "]" }
COMPONENT_OR_SWIZZLE_SPECIFIER = {
    (INDEX_EXPRESSION)
  | ("." ~ SWIZZLE_NAME)
  | ("." ~ IDENT)
}
SINGULAR_EXPRESSION            = {
    PRIMARY_EXPRESSION ~ COMPONENT_OR_SWIZZLE_SPECIFIER*
}
_PLUS                          = { "+" }
_HYPHEN                        = { "-" }
_EXCLAMATION_MARK              = { "!" }
_TILDE                         = { "~" }
_ASTERISK                      = { "*" }
_AMPERSAND                     = { "&" }
_PIPE                          = { "|" }
_FORWARD_SLASH                 = { "/" }
_PERCENT                       = { "%" }
UNARY_EXPRESSION               = {
    (_HYPHEN ~ UNARY_EXPRESSION)
  | (_EXCLAMATION_MARK ~ UNARY_EXPRESSION)
  | (_TILDE ~ UNARY_EXPRESSION)
  | (_ASTERISK ~ UNARY_EXPRESSION)
  | (_AMPERSAND ~ UNARY_EXPRESSION)
  | SINGULAR_EXPRESSION
}
CORE_LHS_EXPRESSION            = {
    IDENT
  | ("(" ~ LHS_EXPRESSION ~ ")")
}
LHS_EXPRESSION                 = {
    (CORE_LHS_EXPRESSION ~ COMPONENT_OR_SWIZZLE_SPECIFIER*)
  | (_ASTERISK ~ LHS_EXPRESSION)
  | (_AMPERSAND ~ LHS_EXPRESSION)
}
MULTIPLICATIVE_OPERATOR        = {
    _ASTERISK
  | _FORWARD_SLASH
  | _PERCENT
}
MULTIPLICATIVE_EXPRESSION      = {
    UNARY_EXPRESSION ~ (MULTIPLICATIVE_OPERATOR ~ UNARY_EXPRESSION)*
}
ADDITIVE_OPERATOR              = {
    _PLUS
  | _HYPHEN
}
ADDITIVE_EXPRESSION            = {
    MULTIPLICATIVE_EXPRESSION ~ (ADDITIVE_OPERATOR ~ MULTIPLICATIVE_EXPRESSION)*
}
_SHIFT_LEFT                    = { "<<" }
_SHIFT_RIGHT                   = { ">>" }
// Variant of shift expression which doesn't have imbalanced top-level `<` or `>` characters, for use in template parameters
TEMPLATE_SHIFT_EXPRESSION = {
    ADDITIVE_EXPRESSION
}
SHIFT_EXPRESSION          = {
    (UNARY_EXPRESSION ~ _SHIFT_LEFT ~ UNARY_EXPRESSION)
  | (UNARY_EXPRESSION ~ _SHIFT_RIGHT ~ UNARY_EXPRESSION)
  | ADDITIVE_EXPRESSION
}
_LESS_THAN                = { "<" }
_GREATER_THAN             = { ">" }
_LESS_THAN_EQUAL          = { "<=" }
_GREATER_THAN_EQUAL       = { ">=" }
_EQUAL_TO                 = { "==" }
_NOT_EQUAL_TO             = { "!=" }
// Variant of relational expression which doesn't have imbalanced top-level `<` or `>` characters, for use in template parameters
TEMPLATE_RELATIONAL_EXPRESSION = {
    (TEMPLATE_SHIFT_EXPRESSION ~ _EQUAL_TO ~ TEMPLATE_SHIFT_EXPRESSION)
  | (TEMPLATE_SHIFT_EXPRESSION ~ _NOT_EQUAL_TO ~ TEMPLATE_SHIFT_EXPRESSION)
  | TEMPLATE_SHIFT_EXPRESSION
}
RELATIONAL_EXPRESSION          = {
    (SHIFT_EXPRESSION ~ _LESS_THAN ~ SHIFT_EXPRESSION)
  | (SHIFT_EXPRESSION ~ _GREATER_THAN ~ SHIFT_EXPRESSION)
  | (SHIFT_EXPRESSION ~ _LESS_THAN_EQUAL ~ SHIFT_EXPRESSION)
  | (SHIFT_EXPRESSION ~ _GREATER_THAN_EQUAL ~ SHIFT_EXPRESSION)
  | (SHIFT_EXPRESSION ~ _EQUAL_TO ~ SHIFT_EXPRESSION)
  | (SHIFT_EXPRESSION ~ _NOT_EQUAL_TO ~ SHIFT_EXPRESSION)
  | SHIFT_EXPRESSION
}
_UPTICK                        = { "^" }
BITWISE_EXPRESSION             = {
    UNARY_EXPRESSION ~ ((_AMPERSAND ~ UNARY_EXPRESSION)+ | (_PIPE ~ UNARY_EXPRESSION)+ | (_UPTICK ~ UNARY_EXPRESSION)+)
}
_DOUBLE_AND                    = { "&&" }
_DOUBLE_OR                     = { "||" }
// Variant of short circuit expression which doesn't have imbalanced top-level `<` or `>` characters, for use in template parameters
TEMPLATE_SHORT_CIRCUIT_EXPRESSION = {
    TEMPLATE_RELATIONAL_EXPRESSION ~ ((_DOUBLE_OR ~ TEMPLATE_RELATIONAL_EXPRESSION)+ | (_DOUBLE_AND ~ TEMPLATE_RELATIONAL_EXPRESSION)+)
}
SHORT_CIRCUIT_EXPRESSION          = {
    RELATIONAL_EXPRESSION ~ ((_DOUBLE_OR ~ RELATIONAL_EXPRESSION)+ | (_DOUBLE_AND ~ RELATIONAL_EXPRESSION)+)
}
// Variant of expression which doesn't have imbalanced top-level `<` or `>` characters, for use in template parameters
TEMPLATE_EXPRESSION = {
    BITWISE_EXPRESSION
  | TEMPLATE_SHORT_CIRCUIT_EXPRESSION
  | TEMPLATE_RELATIONAL_EXPRESSION
}
EXPRESSION          = {
    BITWISE_EXPRESSION
  | SHORT_CIRCUIT_EXPRESSION
  | RELATIONAL_EXPRESSION
}

COMPOUND_STATEMENT = {
    ATTRIBUTE_SET ~ "{" ~ STATEMENT* ~ "}"
}

ASSIGNMENT_STATEMENT = {
    (LHS_EXPRESSION ~ ("=" | COMPOUND_ASSIGNMENT_OPERATOR) ~ EXPRESSION)
  | ("_" ~ "=" ~ EXPRESSION)
}

COMPOUND_ASSIGNMENT_OPERATOR = {
    "+="
  | "-="
  | "*="
  | "/="
  | "%="
  | "&="
  | "|="
  | "^="
  | ">>="
  | "<<="
}

INCREMENT_STATEMENT = {
    LHS_EXPRESSION ~ "++"
}
DECREMENT_STATEMENT = {
    LHS_EXPRESSION ~ "--"
}

IF_KEYWORD     = @{ "if" ~ !CONTINUE }
IF_CLAUSE      =  {
    IF_KEYWORD ~ EXPRESSION ~ "{" ~ STATEMENT* ~ "}"
}
ELSE_KEYWORD   = @{ "else" ~ !CONTINUE }
ELSE_IF_CLAUSE =  {
    ELSE_KEYWORD ~ IF_CLAUSE
}
ELSE_CLAUSE    =  {
    ELSE_KEYWORD ~ "{" ~ STATEMENT* ~ "}"
}
IF_STATEMENT   =  {
    ATTRIBUTE_SET ~ IF_CLAUSE ~ ELSE_IF_CLAUSE* ~ ELSE_CLAUSE?
}

DEFAULT_KEYWORD      = @{ "default" ~ !CONTINUE }
DEFAULT_ALONE_CLAUSE =  {
    DEFAULT_KEYWORD ~ ":"? ~ "{" ~ STATEMENT* ~ "}"
}
CASE_SELECTOR        =  {
    DEFAULT_KEYWORD
  | EXPRESSION
}
CASE_SELECTORS       =  {
    CASE_SELECTOR ~ ("," ~ CASE_SELECTOR)* ~ ","?
}
CASE_KEYWORD         = @{ "case" ~ !CONTINUE }
CASE_CLAUSE          =  {
    CASE_KEYWORD ~ CASE_SELECTORS ~ ":"? ~ "{" ~ STATEMENT* ~ "}"
}
SWITCH_CLAUSE        =  {
    CASE_CLAUSE
  | DEFAULT_ALONE_CLAUSE
}
SWITCH_KEYWORD       = @{ "switch" ~ !CONTINUE }
SWITCH_STATEMENT     =  {
    ATTRIBUTE_SET ~ SWITCH_KEYWORD ~ EXPRESSION ~ "{" ~ SWITCH_CLAUSE+ ~ "}"
}

LOOP_KEYWORD   = @{ "loop" ~ !CONTINUE }
LOOP_STATEMENT =  {
    ATTRIBUTE_SET ~ LOOP_KEYWORD ~ "{" ~ STATEMENT* ~ CONTINUING_STATEMENT? ~ "}"
}

FOR_INIT      =  {
    VARIABLE_OR_VALUE_STATEMENT
  | VARIABLE_UPDATING_STATEMENT
  | FUNC_CALL_STATEMENT
}
FOR_UPDATE    =  {
    VARIABLE_UPDATING_STATEMENT
  | FUNC_CALL_STATEMENT
}
FOR_HEADER    =  {
    FOR_INIT? ~ ";" ~ EXPRESSION? ~ ";" ~ FOR_UPDATE?
}
FOR_KEYWORD   = @{ "for" ~ !CONTINUE }
FOR_STATEMENT =  {
    ATTRIBUTE_SET ~ FOR_KEYWORD ~ "(" ~ FOR_HEADER ~ ")" ~ "{" ~ STATEMENT* ~ "}"
}

WHILE_KEYWORD   = @{ "while" ~ !CONTINUE }
WHILE_STATEMENT =  {
    ATTRIBUTE_SET ~ WHILE_KEYWORD ~ EXPRESSION ~ "{" ~ STATEMENT* ~ "}"
}

BREAK_KEYWORD    = @{ "break" ~ !CONTINUE }
CONTINUE_KEYWORD = @{ "continue" ~ !CONTINUE }

BREAK_STATEMENT    = { BREAK_KEYWORD }
CONTINUE_STATEMENT = { CONTINUE_KEYWORD }

BREAK_IF_STATEMENT = {
    BREAK_KEYWORD ~ IF_KEYWORD ~ EXPRESSION ~ ";"
}

CONTINUING_COMPOUND_STATEMENT =  {
    "{" ~ STATEMENT* ~ BREAK_IF_STATEMENT? ~ "}"
}
CONTINUING_KEYWORD            = @{ "continuing" ~ !CONTINUE }
CONTINUING_STATEMENT          =  {
    CONTINUING_KEYWORD ~ CONTINUING_COMPOUND_STATEMENT
}

RETURN_KEYWORD   = @{ "return" ~ !CONTINUE }
RETURN_STATEMENT =  {
    RETURN_KEYWORD ~ EXPRESSION?
}

CONST_ASSERT_KEYWORD   = @{ "const_assert" ~ !CONTINUE }
CONST_ASSERT_STATEMENT =  {
    CONST_ASSERT_KEYWORD ~ EXPRESSION
}

VARIABLE_UPDATING_STATEMENT =  {
    ASSIGNMENT_STATEMENT
  | INCREMENT_STATEMENT
  | DECREMENT_STATEMENT
}
DISCARD_KEYWORD             = @{ "discard" ~ !CONTINUE }
STATEMENT                   =  {
    ";"
  | (RETURN_STATEMENT ~ ";")
  | (IF_STATEMENT)
  | (SWITCH_STATEMENT)
  | (LOOP_STATEMENT)
  | (FOR_STATEMENT)
  | (WHILE_STATEMENT)
  | (VARIABLE_OR_VALUE_STATEMENT ~ ";")
  | (BREAK_STATEMENT ~ ";")
  | (CONTINUE_STATEMENT ~ ";")
  | (DISCARD_KEYWORD ~ ";")
  | (COMPOUND_STATEMENT)
  | (CONST_ASSERT_STATEMENT ~ ";")
  | (VARIABLE_UPDATING_STATEMENT ~ ";")
  | (FUNC_CALL_STATEMENT ~ ";")
}

PARAM            =  {
    ATTRIBUTE_SET ~ IDENT ~ ":" ~ TYPE_SPECIFIER
}
PARAM_LIST       =  {
    (PARAM ~ ("," ~ PARAM)* ~ ","?)?
}
FUNCTION_RESULT  =  { ATTRIBUTE_SET ~ TEMPLATE_ELABORATED_IDENT }
FUNCTION_KEYWORD = @{ "fn" ~ !CONTINUE }
FUNCTION_HEADER  =  {
    FUNCTION_KEYWORD ~ IDENT ~ "(" ~ PARAM_LIST ~ ")" ~ ("->" ~ FUNCTION_RESULT)?
}
FUNCTION_DECL    =  {
    ATTRIBUTE_SET ~ FUNCTION_HEADER ~ "{" ~ STATEMENT* ~ "}"
}

GLOBAL_DECL      = {
    ";"
  | (GLOBAL_VARIABLE_DECL ~ ";")
  | (GLOBAL_VALUE_DECL ~ ";")
  | (TYPE_ALIAS_DECL ~ ";")
  | STRUCT_DECL
  | FUNCTION_DECL
  | (CONST_ASSERT_STATEMENT ~ ";")
}
TRANSLATION_UNIT = {
    SOI ~ GLOBAL_DIRECTIVE* ~ GLOBAL_DECL* ~ EOI
}
